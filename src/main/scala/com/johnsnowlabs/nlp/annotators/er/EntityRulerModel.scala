/*
 * Copyright 2017-2021 John Snow Labs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.johnsnowlabs.nlp.annotators.er

import com.johnsnowlabs.nlp.AnnotatorType.{CHUNK, DOCUMENT, TOKEN}
import com.johnsnowlabs.nlp.annotators.common.TokenizedWithSentence
import com.johnsnowlabs.nlp.{Annotation, AnnotatorModel, HasPretrained, HasSimpleAnnotate}
import com.johnsnowlabs.storage.Database.{ENTITY_PATTERNS, ENTITY_REGEX_PATTERNS, Name}
import com.johnsnowlabs.storage._
import org.apache.spark.ml.param.{BooleanParam, Param, StringArrayParam}
import org.apache.spark.ml.util.Identifiable
import org.slf4j.{Logger, LoggerFactory}

class EntityRulerModel(override val uid: String) extends AnnotatorModel[EntityRulerModel]
  with HasSimpleAnnotate[EntityRulerModel] with HasStorageModel {

  def this() = this(Identifiable.randomUID("ENTITY_RULER"))

  private val logger: Logger = LoggerFactory.getLogger("Credentials")

  val enablePatternRegex = new BooleanParam(this, "enablePatternRegex",
    "Enables regex pattern match")

  private[er] val regexEntities = new StringArrayParam(this, "regexEntities", "entities defined in regex patterns")

  val optimizeMemory = new BooleanParam(this, "optimizeMemory", "Optimize memory by using disk storage")

  val entitiesMap = new Param[Map[String, String]](this, "entitiesMap", "Entities map")

  def setEnablePatternRegex(value: Boolean): this.type = set(enablePatternRegex, value)

  private[er] def setRegexEntities(value: Array[String]): this.type = set(regexEntities, value)

  def setEntitiesMap(value: Map[String, String]): this.type = set(entitiesMap, value)

  def setOptimizeMemory(value: Boolean): this.type = set(optimizeMemory, value)

  /** Annotator reference id. Used to identify elements in metadata or to refer to this annotator type */
  val inputAnnotatorTypes: Array[String] = Array(DOCUMENT, TOKEN)
  val outputAnnotatorType: AnnotatorType = CHUNK

  /**
   * takes a document and annotations and produces new annotations of this annotator's annotation type
   *
   * @param annotations Annotations that correspond to inputAnnotationCols generated by previous annotators if any
   * @return any number of annotations processed for every input annotation. Not necessary one to one relationship
   */
  def annotate(annotations: Seq[Annotation]): Seq[Annotation] = {

    val tokenizedWithSentences = TokenizedWithSentence.unpack(annotations)

    var annotatedEntities: Seq[Annotation] = Seq()

    if ($(enablePatternRegex)) {
      val regexPatternsReader = getReader(Database.ENTITY_REGEX_PATTERNS).asInstanceOf[RegexPatternsReader]

      annotatedEntities = tokenizedWithSentences.flatMap { tokenizedWithSentence =>
        tokenizedWithSentence.indexedTokens.flatMap { indexedToken =>
          val entity = getMatchedEntity(indexedToken.token, regexPatternsReader)
          if (entity.isDefined) {
            val entityMetadata = getEntityMetadata(entity)
            Some(Annotation(CHUNK, indexedToken.begin, indexedToken.end, indexedToken.token,
              entityMetadata ++ Map("sentence" -> tokenizedWithSentence.sentenceIndex.toString)))
          } else None
        }
      }
    } else {

      if ($(optimizeMemory)) {
        val patternsReader = getReader(Database.ENTITY_PATTERNS).asInstanceOf[PatternsReader]

        annotatedEntities = tokenizedWithSentences.flatMap{ tokenizedWithSentence =>
          tokenizedWithSentence.indexedTokens.flatMap{ indexedToken =>
            val labelData = patternsReader.lookup(indexedToken.token)
            val annotation = if (labelData.isDefined) {
              val entityMetadata = getEntityMetadata(labelData)
              Some(Annotation(CHUNK, indexedToken.begin, indexedToken.end, indexedToken.token,
                entityMetadata ++ Map("sentence" -> tokenizedWithSentence.sentenceIndex.toString)))
            } else None
            annotation
          }
        }
      } else {
        annotatedEntities = tokenizedWithSentences.flatMap{ tokenizedWithSentence =>
          tokenizedWithSentence.indexedTokens.flatMap{ indexedToken =>
            val labelData = $(entitiesMap).get(indexedToken.token)
            val annotation = if (labelData.isDefined) {
              val entityMetadata = getEntityMetadata(labelData)
              Some(Annotation(CHUNK, indexedToken.begin, indexedToken.end, indexedToken.token,
                entityMetadata ++ Map("sentence" -> tokenizedWithSentence.sentenceIndex.toString)))
            } else None
            annotation
          }
        }
      }
    }

    annotatedEntities
  }

  private def getEntityMetadata(labelData: Option[String]): Map[String, String] = {

    val entityMetadata = labelData.get.split(",").zipWithIndex.flatMap{ case(metadata, index) =>
      if (index == 0) {
        Map("entity"-> metadata)
      } else Map("id"-> metadata)
    }.toMap

    entityMetadata
  }

  private def getMatchedEntity(token: String, regexPatternsReader: RegexPatternsReader): Option[String] = {

    val matchesByEntity = $(regexEntities).flatMap{ regexEntity =>
      val regexPatterns: Option[Seq[String]] = regexPatternsReader.lookup(regexEntity)
      if (regexPatterns.isDefined) {
        val matches = regexPatterns.get.flatMap(regexPattern => regexPattern.r.findFirstIn(token))
        if (matches.nonEmpty) Some(regexEntity) else None
      } else None
    }.toSeq

    if (matchesByEntity.size > 1 ) {
      logger.warn("More than one entity found. Sending the first element of the array")
    }

    matchesByEntity.headOption
  }

  protected val databases: Array[Name] = EntityRulerModel.databases

  protected def createReader(database: Name, connection: RocksDBConnection): StorageReader[_] = {
    database match {
      case Database.ENTITY_PATTERNS => new PatternsReader(connection)
      case Database.ENTITY_REGEX_PATTERNS => new RegexPatternsReader(connection)
    }
  }
}

trait ReadablePretrainedEntityRuler extends StorageReadable[EntityRulerModel] with HasPretrained[EntityRulerModel] {

  override val databases: Array[Name] = Array(ENTITY_PATTERNS, ENTITY_REGEX_PATTERNS)

  override val defaultModelName: Option[String] = None

  override def pretrained(): EntityRulerModel = super.pretrained()

  override def pretrained(name: String): EntityRulerModel = super.pretrained(name)

  override def pretrained(name: String, lang: String): EntityRulerModel = super.pretrained(name, lang)

  override def pretrained(name: String, lang: String, remoteLoc: String): EntityRulerModel = super.pretrained(name, lang, remoteLoc)

}

object EntityRulerModel extends ReadablePretrainedEntityRuler