package com.johnsnowlabs.nlp.annotators

import com.johnsnowlabs.nlp.AnnotatorType._
import com.johnsnowlabs.nlp.annotators.common.LabeledDependency
import com.johnsnowlabs.nlp.annotators.common.LabeledDependency.DependencyInfo
import com.johnsnowlabs.nlp.util.GraphBuilder
import com.johnsnowlabs.nlp.{Annotation, AnnotatorModel, AnnotatorType, HasSimpleAnnotate}
import org.apache.spark.ml.util.Identifiable

class GraphExtractor(override val uid: String) extends AnnotatorModel[GraphExtractor] with HasSimpleAnnotate[GraphExtractor] {

  def this() = this(Identifiable.randomUID("DEPENDENCY_PATH"))

  /**
    * takes a document and annotations and produces new annotations of this annotator's annotation type
    *
    * @param annotations Annotations that correspond to inputAnnotationCols generated by previous annotators if any
    * @return any number of annotations processed for every input annotation. Not necessary one to one relationship
    */
  override def annotate(annotations: Seq[Annotation]): Seq[Annotation] = {
    val tokens = annotations.filter(_.annotatorType == AnnotatorType.TOKEN)
    val entities = annotations.filter(annotation => annotation.annotatorType == CHUNK)
    val dependencyData = LabeledDependency.unpackHeadAndRelation(annotations)

    val graph = new GraphBuilder(dependencyData.length + 1)
    dependencyData.zipWithIndex.foreach { case (dependencyInfo, index) =>
      graph.addEdge(dependencyInfo.headIndex, index + 1)
    }

    val sourceDependency = dependencyData.filter(dependencyInfo => dependencyInfo.headIndex == 0)
    if (sourceDependency.size > 1) {
      throw new UnsupportedOperationException("Dependency data has more than one root")
    }
    val sourceIndex = dependencyData.indexOf(sourceDependency.head) + 1
    val entitiesIndexes = getEntitiesIndex(entities, dependencyData)
    val paths = entitiesIndexes.map{ entitiesIndex =>
      val leftPath = graph.depthFirstSearch(sourceIndex, entitiesIndex._1)
      val rightPath = graph.depthFirstSearch(sourceIndex, entitiesIndex._2)
      GraphInfo(entitiesIndex, leftPath, rightPath)
    }

    val sourceToken = tokens(sourceIndex - 1)
    val annotatedPaths = paths.map{ path =>
      val leftEntityToken = tokens(path.entitiesIndex._1 - 1).result
      val rightEntityToken = tokens(path.entitiesIndex._2 - 1).result
      val leftPathTokens = path.leftPathIndex.map(index => tokens(index - 1).result)
      val rightPathTokens = path.rightPathIndex.map(index => tokens(index - 1).result)

      Annotation(VERTEX, sourceToken.begin, sourceToken.end, sourceToken.result,
        Map("entities" -> s"$leftEntityToken,$rightEntityToken",
          "left_path" -> leftPathTokens.mkString("->"), "right_path" -> rightPathTokens.mkString("->"))
      )
    }
    annotatedPaths
  }

  private def getEntitiesIndex(entities: Seq[Annotation], dependencyData: Seq[DependencyInfo]): List[(Int, Int)] = {
    val entitiesPairs = entities.combinations(2).map(entity => (entity.head, entity.last)).toList

    entitiesPairs.map{ entityPair =>
      val dependencyInfo = dependencyData.filter(dependencyInfo =>
        (dependencyInfo.beginToken == entityPair._1.begin && dependencyInfo.endToken == entityPair._1.end) ||
          (dependencyInfo.beginToken == entityPair._2.begin && dependencyInfo.endToken == entityPair._2.end)
      )
      val indexLeft = dependencyData.indexOf(dependencyInfo.head) + 1
      val indexRight = dependencyData.indexOf(dependencyInfo.last) + 1
      (indexLeft, indexRight)
    }
  }

  case class GraphInfo(entitiesIndex: (Int, Int), leftPathIndex: List[Int], rightPathIndex: List[Int])

  override val outputAnnotatorType: AnnotatorType = VERTEX
  /** Annotator reference id. Used to identify elements in metadata or to refer to this annotator type */
  override val inputAnnotatorTypes: Array[String] = Array(TOKEN, DEPENDENCY, LABELED_DEPENDENCY, CHUNK)
}
